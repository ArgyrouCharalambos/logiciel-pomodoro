import {
  debug_default
} from "./chunk-C34TLEZ2.js";
import {
  __export,
  __name
} from "./chunk-JKJYCBCI.js";

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  E_AUTHORIZATION_FAILURE: () => E_AUTHORIZATION_FAILURE
});
import { Exception } from "@poppinss/utils";
var AuthorizationException = class AuthorizationException2 extends Exception {
  static {
    __name(this, "AuthorizationException");
  }
  response;
  message;
  status;
  code;
  /**
  * Error identifier to lookup translation message
  */
  identifier;
  constructor(response, options) {
    super(response.message, options), this.response = response, this.message = "Access denied", this.status = 403, this.code = "E_AUTHORIZATION_FAILURE", this.identifier = "errors.E_AUTHORIZATION_FAILURE";
  }
  /**
  * Returns the message to be sent in the HTTP response.
  * Feel free to override this method and return a custom
  * response.
  */
  getResponseMessage(ctx) {
    const message = this.response.message || this.message;
    if ("i18n" in ctx) {
      const identifier = this.response.translation?.identifier || this.identifier;
      const data = this.response.translation?.data || {};
      return ctx.i18n.t(identifier, data, message);
    }
    return message;
  }
  async handle(_, ctx) {
    const status = this.response.status || this.status;
    const message = this.getResponseMessage(ctx);
    switch (ctx.request.accepts([
      "html",
      "application/vnd.api+json",
      "json"
    ])) {
      case "html":
      case null:
        ctx.response.status(status).send(message);
        break;
      case "json":
        ctx.response.status(status).send({
          errors: [
            {
              message
            }
          ]
        });
        break;
      case "application/vnd.api+json":
        ctx.response.status(status).send({
          errors: [
            {
              code: this.code,
              title: message
            }
          ]
        });
        break;
    }
  }
};
var E_AUTHORIZATION_FAILURE = AuthorizationException;

// src/response.ts
var AuthorizationResponse = class _AuthorizationResponse {
  static {
    __name(this, "AuthorizationResponse");
  }
  authorized;
  /**
  * Create a deny response
  */
  static deny(message, statusCode) {
    const response = new _AuthorizationResponse(false);
    response.message = message;
    response.status = statusCode;
    return response;
  }
  /**
  * Create an allowed response
  */
  static allow() {
    return new _AuthorizationResponse(true);
  }
  constructor(authorized) {
    this.authorized = authorized;
  }
  /**
  * Define the translation identifier for the authorization response
  */
  t(identifier, data) {
    this.translation = {
      identifier,
      data
    };
    return this;
  }
};

// src/bouncer.ts
import { inspect } from "node:util";
import { RuntimeException as RuntimeException2 } from "@poppinss/utils";

// src/ability.ts
function ability(authorizerOrOptions, authorizer) {
  if (typeof authorizerOrOptions === "function") {
    return {
      allowGuest: false,
      original: authorizerOrOptions,
      execute(user, ...args) {
        if (user === null && !this.allowGuest) {
          return AuthorizationResponse.deny();
        }
        return this.original(user, ...args);
      }
    };
  } else {
    return {
      allowGuest: authorizerOrOptions?.allowGuest || false,
      original: authorizer,
      execute(user, ...args) {
        if (user === null && !this.allowGuest) {
          return AuthorizationResponse.deny();
        }
        return this.original(user, ...args);
      }
    };
  }
}
__name(ability, "ability");

// src/abilities_builder.ts
var AbilitiesBuilder = class {
  static {
    __name(this, "AbilitiesBuilder");
  }
  abilities;
  constructor(abilities) {
    this.abilities = abilities;
  }
  /**
  * Helper to convert a user defined authorizer function to a bouncer ability
  */
  define(name, authorizer, options) {
    this.abilities[name] = ability(options || {
      allowGuest: false
    }, authorizer);
    return this;
  }
};

// src/policy_authorizer.ts
import { RuntimeException } from "@poppinss/utils";
var KNOWN_POLICIES_CACHE = /* @__PURE__ */ new Map();
var PolicyAuthorizer = class {
  static {
    __name(this, "PolicyAuthorizer");
  }
  #policy;
  #policyImporter;
  /**
  * Reference to the resolved user
  */
  #user;
  /**
  * Reference to the IoC container resolver. It is needed
  * to optionally construct policy class instances
  */
  #containerResolver;
  /**
  * Emitter to emit events
  */
  #emitter;
  /**
  * Response builder is used to normalize bouncer responses
  */
  #responseBuilder;
  constructor(user, policy, responseBuilder) {
    this.#user = user;
    this.#policyImporter = policy;
    this.#responseBuilder = responseBuilder;
  }
  /**
  * Check if a policy method allows guest users
  */
  #policyAllowsGuests(Policy, action) {
    const actionsMetaData = "actionsMetaData" in Policy && Policy.actionsMetaData;
    if (!actionsMetaData || !actionsMetaData[action]) {
      return false;
    }
    return !!actionsMetaData[action].allowGuest;
  }
  /**
  * Check to see if policy is defined as a class
  */
  #isPolicyAsClass(policy) {
    return typeof policy === "function" && policy.toString().startsWith("class ");
  }
  /**
  * Resolves the policy from the importer and caches it for
  * repetitive use.
  */
  async #resolvePolicy() {
    if (this.#policy && !("hot" in import.meta)) {
      return this.#policy;
    }
    if (KNOWN_POLICIES_CACHE.has(this.#policyImporter)) {
      debug_default("reading policy from the imports cache %O", this.#policyImporter);
      return KNOWN_POLICIES_CACHE.get(this.#policyImporter);
    }
    const policyOrImport = this.#policyImporter;
    if (this.#isPolicyAsClass(policyOrImport)) {
      this.#policy = policyOrImport;
    } else {
      debug_default("lazily importing policy %O", this.#policyImporter);
      const policyExports = await policyOrImport();
      this.#policy = policyExports.default;
    }
    if (!("hot" in import.meta)) {
      KNOWN_POLICIES_CACHE.set(this.#policyImporter, this.#policy);
    }
    return this.#policy;
  }
  /**
  * Emits the event and sends normalized response
  */
  #emitAndRespond(action, result, args) {
    const response = this.#responseBuilder(result);
    if (this.#emitter) {
      this.#emitter.emit("authorization:finished", {
        user: this.#user,
        action: `${this.#policy?.name}.${action}`,
        response,
        parameters: args
      });
    }
    return response;
  }
  /**
  * Executes the after hook on policy and handles various
  * flows around using original or modified response.
  */
  async #executeAfterHook(policy, action, result, args) {
    if (typeof policy.after !== "function") {
      return this.#emitAndRespond(action, result, args);
    }
    const modifiedResponse = await policy.after(this.#user, action, result, ...args);
    if (typeof modifiedResponse === "boolean" || modifiedResponse instanceof AuthorizationResponse) {
      return this.#emitAndRespond(action, modifiedResponse, args);
    }
    return this.#emitAndRespond(action, result, args);
  }
  /**
  * Set a container resolver to use for resolving policies
  */
  setContainerResolver(containerResolver) {
    this.#containerResolver = containerResolver;
    return this;
  }
  /**
  * Define the event emitter instance to use for emitting
  * authorization events
  */
  setEmitter(emitter) {
    this.#emitter = emitter;
    return this;
  }
  /**
  * Execute an action from the list of pre-defined actions
  */
  async execute(action, ...args) {
    const Policy = await this.#resolvePolicy();
    const policyInstance = this.#containerResolver ? await this.#containerResolver.make(Policy) : new Policy();
    if (typeof policyInstance[action] !== "function") {
      throw new RuntimeException(`Cannot find method "${action}" on "[class ${Policy.name}]"`);
    }
    let hookResponse;
    if (typeof policyInstance.before === "function") {
      hookResponse = await policyInstance.before(this.#user, action, ...args);
    }
    if (typeof hookResponse === "boolean" || hookResponse instanceof AuthorizationResponse) {
      return this.#executeAfterHook(policyInstance, action, hookResponse, args);
    }
    if (this.#user === null && !this.#policyAllowsGuests(Policy, action)) {
      return this.#executeAfterHook(policyInstance, action, AuthorizationResponse.deny(), args);
    }
    const response = await policyInstance[action](this.#user, ...args);
    return this.#executeAfterHook(policyInstance, action, response, args);
  }
  /**
  * Check if a user is allowed to perform an action using
  * one of the known policy methods
  */
  async allows(action, ...args) {
    const response = await this.execute(action, ...args);
    return response.authorized;
  }
  /**
  * Check if a user is denied from performing an action using
  * one of the known policy methods
  */
  async denies(action, ...args) {
    const response = await this.execute(action, ...args);
    return !response.authorized;
  }
  /**
  * Authorize a user against a given policy action
  *
  * @throws {@link E_AUTHORIZATION_FAILURE}
  */
  async authorize(action, ...args) {
    const response = await this.execute(action, ...args);
    if (!response.authorized) {
      throw new E_AUTHORIZATION_FAILURE(response);
    }
  }
};

// src/bouncer.ts
var Bouncer = class _Bouncer {
  static {
    __name(this, "Bouncer");
  }
  /**
  * Response builder is used to normalize bouncer responses
  */
  static responseBuilder = /* @__PURE__ */ __name((response) => {
    return typeof response === "boolean" ? new AuthorizationResponse(response) : response;
  }, "responseBuilder");
  /**
  * Define an ability using the AbilityBuilder
  */
  static define(name, authorizer, options) {
    return new AbilitiesBuilder({}).define(name, authorizer, options);
  }
  /**
  * Emitter to emit events
  */
  static emitter;
  /**
  * Define a bouncer ability from a callback
  */
  static ability = ability;
  /**
  * User resolver to lazily resolve the user
  */
  #userOrResolver;
  /**
  * Reference to the resolved user
  */
  #user;
  /**
  * Pre-defined abilities
  */
  abilities;
  /**
  * Pre-defined policies
  */
  policies;
  /**
  * Reference to the container resolver to construct
  * policy classes.
  */
  #containerResolver;
  /**
  * An object with helpers to be shared with Edge for
  * performing authorization.
  */
  edgeHelpers = {
    bouncer: {
      parent: this,
      can(action, ...args) {
        const [policyName, ...policyMethods] = action.split(".");
        if (policyMethods.length) {
          return this.parent.with(policyName).allows(policyMethods.join("."), ...args);
        }
        return this.parent.allows(policyName, ...args);
      },
      cannot(action, ...args) {
        const [policyName, ...policyMethods] = action.split(".");
        if (policyMethods.length) {
          return this.parent.with(policyName).denies(policyMethods.join("."), ...args);
        }
        return this.parent.denies(policyName, ...args);
      }
    }
  };
  constructor(userOrResolver, abilities, policies) {
    this.#userOrResolver = userOrResolver;
    this.abilities = abilities;
    this.policies = policies;
  }
  /**
  * Returns reference to the user object
  */
  #getUser() {
    if (this.#user === void 0) {
      if (typeof this.#userOrResolver === "function") {
        this.#user = this.#userOrResolver();
      } else {
        this.#user = this.#userOrResolver;
      }
    }
    return this.#user;
  }
  /**
  * Emits the event and sends normalized response
  */
  #emitAndRespond(abilitiy, result, args) {
    const response = _Bouncer.responseBuilder(result);
    if (_Bouncer.emitter) {
      _Bouncer.emitter.emit("authorization:finished", {
        user: this.#user,
        action: abilitiy,
        response,
        parameters: args
      });
    }
    return response;
  }
  with(policy) {
    if (typeof policy !== "function") {
      if (!this.policies || !this.policies[policy]) {
        throw new RuntimeException2(`Invalid bouncer policy "${inspect(policy)}"`);
      }
      return new PolicyAuthorizer(this.#getUser(), this.policies[policy], _Bouncer.responseBuilder).setContainerResolver(this.#containerResolver).setEmitter(_Bouncer.emitter);
    }
    return new PolicyAuthorizer(this.#getUser(), policy, _Bouncer.responseBuilder).setContainerResolver(this.#containerResolver).setEmitter(_Bouncer.emitter);
  }
  /**
  * Set a container resolver to use for resolving policies
  */
  setContainerResolver(containerResolver) {
    this.#containerResolver = containerResolver;
    return this;
  }
  async execute(ability2, ...args) {
    if (this.abilities && this.abilities[ability2]) {
      debug_default('executing pre-registered ability "%s"', ability2);
      return this.#emitAndRespond(ability2, await this.abilities[ability2].execute(this.#getUser(), ...args), args);
    }
    if (!ability2 || typeof ability2 !== "object" || "execute" in ability2 === false) {
      throw new RuntimeException2(`Invalid bouncer ability "${inspect(ability2)}"`);
    }
    if (debug_default.enabled) {
      debug_default('executing ability "%s"', ability2.name);
    }
    return this.#emitAndRespond(ability2.original.name, await ability2.execute(this.#getUser(), ...args), args);
  }
  async allows(ability2, ...args) {
    const response = await this.execute(ability2, ...args);
    return response.authorized;
  }
  async denies(action, ...args) {
    const response = await this.execute(action, ...args);
    return !response.authorized;
  }
  async authorize(ability2, ...args) {
    const response = await this.execute(ability2, ...args);
    if (!response.authorized) {
      throw new E_AUTHORIZATION_FAILURE(response);
    }
  }
  /**
  * Create AuthorizationResponse to deny access
  */
  deny(message, status) {
    return AuthorizationResponse.deny(message, status);
  }
};

export {
  errors_exports,
  AuthorizationResponse,
  Bouncer
};
